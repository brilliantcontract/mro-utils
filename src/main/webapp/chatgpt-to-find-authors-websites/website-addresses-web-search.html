<!DOCTYPE html>
<html lang="en">
    <head>
        <title>JavaScript documentation</title>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />

        <!-- Bootstrap / JQuery / Knockout. -->
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.2/dist/css/bootstrap.min.css" integrity="sha384-xOolHFLEh07PJGoPkLv1IbcEPTNtaed2xpHsD9ESMhqIYd0nLMwNLD69Npy4HI+N" crossorigin="anonymous" />
        <script src="https://code.jquery.com/jquery-3.5.1.min.js" integrity="sha256-9/aliU8dGd2tb6OSsuzixeV4y/faTqgFtohetphbbj0=" crossorigin="anonymous"></script>
        <script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.1/dist/umd/popper.min.js" integrity="sha384-9/reFTGAW83EW2RDu2S0VKaIzap3H66lZH81PoYlFhbGU+6BZp6G7niu735Sk7lN" crossorigin="anonymous"></script>
        <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.2/dist/js/bootstrap.min.js" integrity="sha384-+sLIOodYLS7CIrQpBjl+C7nPvqq+FbNUBDunl/OZv93DB7Ln/533i8e/mZXLi/P+" crossorigin="anonymous"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/knockout/3.5.0/knockout-min.js"></script>
    </head>
    <body class="container mt-3">
        <h1 class="h2 mb-3 mt-5">Website addresses web search</h1>
        <h5 class="mb-4">OpenAI gpt-4o using web search tool</h5>

        <form>
            <div class="input-group mb-3">
                <div class="input-group-prepend">
                    <label class="input-group-text">API Key</label>
                </div>
                <input type="password" data-bind="value: apiKey" class="form-control" />
            </div>

            <div class="mb-3">
                <span class="mr-2 font-weight-bold">Prompt type:</span>
                <div class="form-check form-check-inline">
                    <input class="form-check-input" type="radio" name="promptChoice" id="promptSingle" data-bind="checked: selectedPrompt, value: 'single'">
                    <label class="form-check-label" for="promptSingle">Single author</label>
                </div>
                <div class="form-check form-check-inline">
                    <input class="form-check-input" type="radio" name="promptChoice" id="promptMultiple" data-bind="checked: selectedPrompt, value: 'multiple'">
                    <label class="form-check-label" for="promptMultiple">Multiple authors</label>
                </div>
            </div>

            <div class="input-group mb-4">
                <div class="input-group-prepend">
                    <label class="input-group-text">User</label>
                </div>
                <textarea data-bind="value: query" class="form-control" rows="10" required></textarea>
            </div>

            <div class="input-group mb-4">
                <div class="input-group-prepend">
                    <label class="input-group-text">System</label>
                </div>
                <textarea data-bind="value: systemPrompt" class="form-control" rows="6" required></textarea>
            </div>

            <input type="button" data-bind="click: send" value="Send" class="btn btn-outline-dark btn-lg" />
        </form>

        <h3 class="h4 mt-5">Answer</h3>
        <div class="border border-dark shadow p-3 mb-5 bg-white rounded">
            <pre data-bind="text: answer" class="text-break"></pre>
        </div>

        <script src="./responses-utils.js"></script>
        <script>
        function openDb() {
            return new Promise(function(resolve, reject){
                const req = indexedDB.open('websiteSearch', 1);
                req.onupgradeneeded = function(e){
                    const db = e.target.result;
                    if (!db.objectStoreNames.contains('config')) {
                        db.createObjectStore('config');
                    }
                };
                req.onsuccess = function(e){ resolve(e.target.result); };
                req.onerror = function(e){ reject(e.target.error); };
            });
        }

        async function loadApiKey() {
            const db = await openDb();
            return new Promise(function(resolve, reject){
                const tx = db.transaction('config', 'readonly');
                const req = tx.objectStore('config').get('apiKey');
                req.onsuccess = function(){ resolve(req.result || ''); };
                req.onerror = function(e){ reject(e.target.error); };
            });
        }

        async function saveApiKey(key) {
            const db = await openDb();
            return new Promise(function(resolve, reject){
                const tx = db.transaction('config', 'readwrite');
                tx.objectStore('config').put(key, 'apiKey');
                tx.oncomplete = function(){ resolve(); };
                tx.onerror = function(e){ reject(e.target.error); };
            });
        }

        async function askWebSearch(systemMsg, userMsg, apiKey) {
            const apiRequest = new Request('https://api.openai.com/v1/responses', {
                method: 'POST',
                headers: {
                    'Authorization': 'Bearer ' + apiKey,
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(buildResponsesBody(systemMsg, userMsg))
            });

            let answer;
            try {
                const response = await fetch(apiRequest);
                const json = await response.json();
                if (json.error) {
                    answer = json.error.message;
                } else if (Array.isArray(json.output)) {
                    var msg = json.output.find(function(o){ return o.type === 'message'; });
                    if (msg && Array.isArray(msg.content)) {
                        answer = msg.content.map(function(c){ return c.text; }).join('');
                    } else {
                        answer = JSON.stringify(json);
                    }
                } else {
                    answer = JSON.stringify(json);
                }
            } catch (ex) {
                answer = 'Error: ' + ex;
            }
            return answer;
        }

        function FormModel() {
            var self = this;

            const promptForSingleAuthor = `You are a research assistant. I will give you the name of an author. Perform a web search and return ONLY the URL of the contact page of their official personal website. If no contact page is available, return the homepage URL of their personal website.

Do not return any social media profiles, publisher pages, shared blogs, or professional directory profiles.

Author: [AUTHOR NAME]`;

            const promptForMultipleAuthors = `You are a research assistant. For each of the authors listed below, perform a web search and return ONLY the URL of the contact page of their official personal website. If no contact page exists, return the homepage URL of their personal website instead.

Do not return social media profiles, publisher pages, shared blogs, or academic directories.

Authors:
    [Author Name 1]
    [Author Name 2]
    [Author Name 3]
    ! MAX 10 QTY !`;

            const systemPromptForSingleAuthor = `Perform a web search to find the newest data in the Internet.
If the author does not appear to have a personal website, respond exactly with: NOT FOUND.
When you DO find a site, respond with only the URL \u2014 no other text.
No comments, details, descriptions, or notes.`;

            const systemPromptForMultipleAuthors = `For each of the listed authors, perform a web search.
If an author has no personal website, write: NOT FOUND.
Return only the URL or NOT FOUND, one line per author, like:
[Author]: [URL|NOT FOUND]

No comments, details, descriptions, or notes.`;

            const userPrompts = {
                single: promptForSingleAuthor,
                multiple: promptForMultipleAuthors
            };
            const systemPrompts = {
                single: systemPromptForSingleAuthor,
                multiple: systemPromptForMultipleAuthors
            };

            self.apiKey = ko.observable('');
            self.selectedPrompt = ko.observable('single');
            self.query = ko.observable(userPrompts.single);
            self.systemPrompt = ko.observable(systemPrompts.single);
            self.answer = ko.observable('');

            loadApiKey().then(function(key){ self.apiKey(key); });
            self.apiKey.subscribe(function(val){ saveApiKey(val); });

            self.selectedPrompt.subscribe(function(key){
                self.query(userPrompts[key]);
                self.systemPrompt(systemPrompts[key]);
            });

            self.send = function(){
                var userMsg = self.query().trim();
                var systemMsg = self.systemPrompt().trim();

                if (!userMsg || !systemMsg || !self.apiKey().trim()) {
                    self.answer('Please fill API key and both prompt fields.');
                    return;
                }

                self.answer('Query has been sent to chatbot. Waiting answer \u2026');
                askWebSearch(systemMsg, userMsg, self.apiKey())
                    .then(self.answer)
                    .catch(function(err){
                        console.error(err);
                        self.answer('Error: ' + err.message);
                    });
            };
        }

        ko.applyBindings(new FormModel());
        </script>
    </body>
</html>
